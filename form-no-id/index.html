<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firefox Passkey Autofill 検証ページ</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background-color: #f5f5f5;
    padding: 20px;
    line-height: 1.6;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    background: white;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

h1 {
    color: #333;
    margin-bottom: 10px;
    text-align: center;
}

h2 {
    color: #555;
    margin-bottom: 15px;
    font-size: 1.3em;
}

h3 {
    color: #666;
    margin: 20px 0 15px 0;
    font-size: 1.1em;
    border-bottom: 1px solid #ddd;
    padding-bottom: 5px;
}

.description {
    text-align: center;
    color: #666;
    margin-bottom: 30px;
}

section {
    margin-bottom: 40px;
}

.form-group {
    margin-bottom: 10px;
}

label {
    display: block;
    margin-bottom: 5px;
    color: #666;
    font-weight: 500;
    font-size: 0.9em;
}

input[type="text"],
input[type="email"],
input[type="password"] {
    width: 100%;
    padding: 12px;
    border: 2px solid #ddd;
    border-radius: 4px;
    font-size: 16px;
    transition: border-color 0.3s;
}

input:focus {
    outline: none;
    border-color: #4CAF50;
}

.btn {
    background-color: #4CAF50;
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 4px;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.3s;
    width: 100%;
}

.btn:hover {
    background-color: #45a049;
}

.btn:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}

.status {
    margin-top: 15px;
    padding: 12px;
    border-radius: 4px;
    font-size: 14px;
}

.status.success {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.status.error {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

.status.info {
    background-color: #d1ecf1;
    color: #0c5460;
    border: 1px solid #bee5eb;
}

.status:empty {
    display: none;
}

.test-form {
    margin-bottom: 15px;
    padding: 10px;
    border-radius: 5px;
}

.test-form.expect-success {
    border: 2px solid #4CAF50;
}

.test-form.expect-fail {
    border: 2px solid #f44336;
}

.assertion-section {
    margin-top: 30px;
    padding-top: 30px;
    border-top: 2px solid #e0e0e0;
}

.assertion-details {
    background-color: #f9f9f9;
    padding: 20px;
    border-radius: 6px;
}

.detail-group {
    margin-bottom: 25px;
}

.detail-group:last-child {
    margin-bottom: 0;
}

.detail-group h3 {
    color: #333;
    font-size: 1.1em;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #ddd;
}

.detail-item {
    margin-bottom: 15px;
}

.detail-item:last-child {
    margin-bottom: 0;
}

.detail-item strong {
    display: block;
    color: #555;
    margin-bottom: 6px;
    font-size: 0.95em;
}

.detail-value {
    padding: 10px;
    background-color: white;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    font-size: 0.9em;
}

.hex-value {
    font-family: 'Courier New', Courier, monospace;
    word-break: break-all;
    color: #2c3e50;
}

.json-value {
    font-family: 'Courier New', Courier, monospace;
    white-space: pre-wrap;
    color: #2c3e50;
    max-height: 200px;
    overflow-y: auto;
}

.flags-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 6px;
}

.flag-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background-color: white;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    font-size: 0.9em;
}

.flag-true {
    color: #4CAF50;
    font-weight: bold;
    font-size: 1.1em;
}

.flag-false {
    color: #ccc;
    font-weight: bold;
    font-size: 1.1em;
}

.legend {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    font-size: 0.9em;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
}

.legend-box {
    width: 20px;
    height: 20px;
    border-radius: 3px;
    border: 2px solid;
}

.legend-box.success {
    border-color: #4CAF50;
}

.legend-box.fail {
    border-color: #f44336;
}
    </style>
</head>
<body>
    <div class="container">
        <h1>Firefox Passkey Autofill 検証ページ</h1>
        <p class="description">各inputフィールドでPasskey Autofillが発動するかテストできます</p>

        <section class="register-section">
            <h2>パスキーの登録</h2>
            <button id="registerButton" class="btn">パスキーを登録</button>
            <div id="registerStatus" class="status"></div>
        </section>

        <section class="login-section">
            <h2>Passkey Autofill 発動条件テスト</h2>

            <div class="legend">
                <div class="legend-item"><div class="legend-box success"></div> 発動期待</div>
                <div class="legend-item"><div class="legend-box fail"></div> 発動しない期待</div>
            </div>

            <h3>autocomplete属性のバリエーション</h3>

            <form novalidate="" class="test-form expect-success">
                <div class="form-group">
                    <label><strong>1. autocomplete="username webauthn"</strong></label>
                    <input type="text" name="test1" autocomplete="username webauthn" placeholder="Form1">
                </div>
            </form>

            <form novalidate="" class="test-form expect-fail">
                <div class="form-group">
                    <label><strong>2. autocomplete="email webauthn"</strong></label>
                    <input type="text" name="test2" autocomplete="email webauthn" placeholder="Form2">
                </div>
            </form>

            <form novalidate="" class="test-form expect-fail">
                <div class="form-group">
                    <label><strong>3. autocomplete="webauthn username" (順序逆)</strong></label>
                    <input type="text" name="test3" autocomplete="webauthn username" placeholder="Form3">
                </div>
            </form>

            <form novalidate="" class="test-form expect-fail">
                <div class="form-group">
                    <label><strong>4. autocomplete="webauthn email" (順序逆)</strong></label>
                    <input type="text" name="test4" autocomplete="webauthn email" placeholder="Form4">
                </div>
            </form>

            <h3>autocomplete="webauthn" 単独 + 追加条件</h3>

            <form novalidate="" class="test-form expect-success">
                <div class="form-group">
                    <label><strong>5. autocomplete="webauthn" + type="password"</strong></label>
                    <input type="password" name="test5" autocomplete="webauthn" placeholder="Form5">
                </div>
            </form>

            <form novalidate="" class="test-form expect-success">
                <div class="form-group">
                    <label><strong>6. autocomplete="webauthn" + name="username"</strong></label>
                    <input type="text" name="username" autocomplete="webauthn" placeholder="Form6">
                </div>
            </form>

            <form novalidate="" class="test-form expect-fail">
                <div class="form-group">
                    <label><strong>7. autocomplete="webauthn" + name="email"</strong></label>
                    <input type="text" name="email" autocomplete="webauthn" placeholder="Form7">
                </div>
            </form>

            <form novalidate="" class="test-form expect-fail">
                <div class="form-group">
                    <label><strong>8. autocomplete="webauthn" + name="password" + type="text"</strong></label>
                    <input type="text" name="password" autocomplete="webauthn" placeholder="Form8">
                </div>
            </form>

            <div id="loginStatus" class="status"></div>
        </section>

        <section class="assertion-section" id="assertionSection" style="display: none;">
            <h2>Assertion Details</h2>
            <div id="assertionDetails" class="assertion-details"></div>
        </section>
    </div>

    <script>
// AbortController for conditional authentication
let conditionalAuthAbortController = null;

// Generate random challenge per WebAuthn specification
function generateChallenge() {
    const buffer = new Uint8Array(32);
    crypto.getRandomValues(buffer);
    return buffer;
}

// Show status message
function showStatus(elementId, message, type) {
    const statusElement = document.getElementById(elementId);
    statusElement.textContent = message;
    statusElement.className = `status ${type}`;
}

// Helper function to convert ArrayBuffer or Uint8Array to hex string
function arrayBufferToHex(buffer) {
    return Array.from(new Uint8Array(buffer))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
}

// Parse authenticator data from credential response
function parseAuthenticatorData(authData) {
    const dataView = new DataView(authData.buffer, authData.byteOffset, authData.byteLength);
    const rpIdHash = new Uint8Array(authData.slice(0, 32));
    const flags = dataView.getUint8(32);
    const signCount = dataView.getUint32(33, false);

    return {
        rpIdHash: arrayBufferToHex(rpIdHash),
        flags: {
            userPresent: !!(flags & 0x01),
            userVerified: !!(flags & 0x04),
            backupEligible: !!(flags & 0x08),
            backupState: !!(flags & 0x10),
            attestedCredentialData: !!(flags & 0x40),
            extensionDataIncluded: !!(flags & 0x80)
        },
        flagsByte: flags,
        signCount: signCount
    };
}

// Display assertion details in UI
function displayAssertionDetails(credential) {
    const response = credential.response;
    const authData = new Uint8Array(response.authenticatorData);
    const parsedData = parseAuthenticatorData(authData);

    const assertionSection = document.getElementById('assertionSection');
    const assertionDetails = document.getElementById('assertionDetails');

    const flagsHtml = Object.entries(parsedData.flags)
        .map(([key, value]) => {
            const status = value ? '✓' : '✗';
            const className = value ? 'flag-true' : 'flag-false';
            return `<div class="flag-item"><span class="${className}">${status}</span> ${key}</div>`;
        })
        .join('');

    const clientDataText = new TextDecoder().decode(response.clientDataJSON);

    const html = `
        <div class="detail-group">
            <h3>Credential ID</h3>
            <div class="detail-value hex-value">${arrayBufferToHex(credential.rawId)}</div>
        </div>
        <div class="detail-group">
            <h3>Authenticator Data</h3>
            <div class="detail-item">
                <strong>RP ID Hash:</strong>
                <div class="detail-value hex-value">${parsedData.rpIdHash}</div>
            </div>
            <div class="detail-item">
                <strong>Flags (0x${parsedData.flagsByte.toString(16).padStart(2, '0')}):</strong>
                <div class="flags-list">${flagsHtml}</div>
            </div>
            <div class="detail-item">
                <strong>Sign Count:</strong>
                <div class="detail-value">${parsedData.signCount}</div>
            </div>
        </div>
        <div class="detail-group">
            <h3>Client Data JSON</h3>
            <div class="detail-value json-value"></div>
        </div>
        <div class="detail-group">
            <h3>Signature</h3>
            <div class="detail-value hex-value">${arrayBufferToHex(response.signature)}</div>
        </div>
    `;

    assertionDetails.innerHTML = html;
    assertionDetails.querySelector('.json-value').textContent = clientDataText;
    assertionSection.style.display = 'block';
}

// Register a new passkey
async function registerPasskey() {
    const registerButton = document.getElementById('registerButton');
    registerButton.disabled = true;
    showStatus('registerStatus', '登録処理中...', 'info');

    if (conditionalAuthAbortController) {
        conditionalAuthAbortController.abort();
        conditionalAuthAbortController = null;
    }

    try {
        const challenge = generateChallenge();
        const userId = generateChallenge();
        const userName = 'test-user';
        const userDisplayName = 'Test User';

        const createCredentialOptions = {
            publicKey: {
                challenge: challenge,
                rp: {
                    name: "Passkey Autofill Test",
                    id: window.location.hostname,
                },
                user: {
                    id: userId,
                    name: userName,
                    displayName: userDisplayName,
                },
                pubKeyCredParams: [
                    { type: "public-key", alg: -7 },
                    { type: "public-key", alg: -257 }
                ],
                authenticatorSelection: {
                    authenticatorAttachment: "platform",
                    requireResidentKey: true,
                    residentKey: "required",
                    userVerification: "required"
                },
                timeout: 60000,
                attestation: "none"
            }
        };

        const credential = await navigator.credentials.create(createCredentialOptions);

        console.log('Credential created:', credential);
        showStatus('registerStatus', 'パスキーの登録に成功しました！', 'success');

        setTimeout(() => {
            window.location.reload();
        }, 0);
    } catch (error) {
        console.error('Registration failed:', error);
        showStatus('registerStatus', `登録に失敗しました: ${error.message}`, 'error');
    } finally {
        registerButton.disabled = false;
        conditionalAuthentication();
    }
}

// Perform conditional authentication (autofill)
async function conditionalAuthentication() {
    if (conditionalAuthAbortController) {
        conditionalAuthAbortController.abort();
        conditionalAuthAbortController = null;
    }

    const abortController = new AbortController();
    conditionalAuthAbortController = abortController;

    try {
        if (!window.PublicKeyCredential ||
            !PublicKeyCredential.isConditionalMediationAvailable) {
            console.log('Conditional mediation not supported');
            return;
        }

        const available = await PublicKeyCredential.isConditionalMediationAvailable();
        if (!available) {
            console.log('Conditional mediation not available');
            return;
        }

        const challenge = generateChallenge();

        const getCredentialOptions = {
            publicKey: {
                challenge: challenge,
                rpId: window.location.hostname,
                userVerification: "required",
                timeout: 60000
            },
            mediation: "conditional",
            signal: abortController.signal
        };

        const credential = await navigator.credentials.get(getCredentialOptions);

        if (credential) {
            console.log('Authentication successful:', credential);
            showStatus('loginStatus', '認証に成功しました！', 'success');
            displayAssertionDetails(credential);
            return credential;
        }
    } catch (error) {
        if (error.name !== 'NotAllowedError' && error.name !== 'AbortError') {
            console.error('Authentication failed:', error);
            showStatus('loginStatus', `認証に失敗しました: ${error.message}`, 'error');
        }
    } finally {
        if (conditionalAuthAbortController === abortController) {
            conditionalAuthAbortController = null;
        }
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    const registerButton = document.getElementById('registerButton');
    registerButton.addEventListener('click', registerPasskey);

    conditionalAuthentication();
});
    </script>
</body>
</html>
